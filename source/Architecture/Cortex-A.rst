
=========================
Cortex-A 架构简单介绍
=========================


ARM基础（遇到多少记多少）
==========================
    一、ARM流水线技术基础知识
    
    参考:https://blog.csdn.net/YH3608/article/details/83315103

    流水线技术通过多个功能部件并行工作来缩短程序执行时间,提高处理器的效率和吞吐率。ARM7是冯·诺依曼结构,采用了典型的三级流水线,而ARM9则是哈佛结构,采用五级流水线技术,而ARM11则更是使用了8级流水线。通过增加流水线级数,简化了流水线的各级逻辑,进一步提高了处理器的性能。
    在ARM7中,执行单元完成了大量的工作,包括与操作数相关的寄存器和存储器的读写操作、ALU操作和相关器件之间的数据传输,因此占用了多个时钟周期。ARM9增加了两个功能部件,分别访问存储器并写回结果,同时,ARM9将读寄存器的操作转移到译码部件上,使得流水线各部件的功能更平衡。

    以三级流水线分析:
      pc代表程序计数器,流水线使用三个阶段,因此指令分为三个阶段执行:
        1.取指（从存储器装载一条指令）。

        2.译码（识别将要被执行的指令）。

        3.执行（处理指令并将结果写回寄存器）。


Cortex-A
=========================

--------------------------------
Cortex-A 处理器运行模型
--------------------------------

    Cortex-A7 处理器有 9 种处理模式。

    ====================   ============================================================
    模式                    描述
    ====================   ============================================================
    User(USR)               用户模式,非特权模式,大部分程序运行的时候就处于此模式。
    FIQ                     快速中断模式,进入 FIQ 中断异常
    IRQ                     一般中断模式。
    Supervisor(SVC)         超级管理员模式,特权模式,供操作系统使用。
    Monitor(MON)            监视模式,这个模式用于安全扩展模式。
    Abort(ABT)              数据访问终止模式,用于虚拟存储以及存储保护。
    Hyp(HYP)                超级监视模式,用于虚拟化扩展。
    Undef(UND)              未定义指令终止模式。
    System(SYS)             系统模式,用于运行特权级的操作系统任务
    ====================   ============================================================

    除USER外,其余8种模式都是特权模式。这几个运行模式可以通过软件进行任意切换,
    也可以通过中断或者异常来进行切换。大多数的程序都运行在用户模式,用户模式下是
    不能访问系统所有资源的,有些资源是受限的,要想访问这些受限的资源就必须进行模
    式切换。

    用户模式下需要借助异常来完成模式切换,当要切换模式的时候,应用程序可以产生异常,
    在异常的处理过程中完成处理器模式切换。

    当中断或者异常发生以后,处理器就会进入到相应的异常模式种,每一种模式都有一组寄
    存器供异常处理程序使用,这样的目的是为了保证在进入异常模式以后,用户模式下的寄存器
    不会被破坏。

--------------------------------
Cortex-A 寄存器组
--------------------------------
    ARM 架构提供了 16 个 32 位的通用寄存器(R0~R15)供软件使用,前 15 个(R0~R14)可以用
    作通用的数据存储,R15 是程序计数器 PC,用来保存将要执行的指令。ARM 还提供了一个当
    前程序状态寄存器 CPSR 和一个备份程序状态寄存器 SPSR,SPSR 寄存器就是 CPSR 寄存器的
    备份。

    ..  image:: ./Picture/Cortex-A_Resister.png

    Cortex-A7 有 9 种运行模式,每一种运行模式都有一组与之对应的寄存
    器组。每一种模式可见的寄存器包括 15 个通用寄存器(R0~R14)、一两个程序状态寄存器和一个
    程序计数器 PC。在这些寄存器中,有些是所有模式所共用的同一个物理寄存器,有一些是各模
    式自己所独立拥有的,各个模式所拥有的寄存器如下图示:

    ..  image:: ./Picture/Cortex-A_ResisterForModes.png

    浅色字体的是与 User 模式所共有的寄存器,蓝绿色背景的是各个模式所独有
    的寄存器。在所有的模式中,低寄存器组(R0~R7)是共享同一组物理寄存器的,只是
    一些高寄存器组在不同的模式有自己独有的寄存器。比如 FIQ 模式下 R8~R14 是独立的物理寄
    存器。假如某个程序在 FIQ 模式下访问 R13 寄存器,那它实际访问的是寄存器 R13_fiq。

    Cortex-A 内核寄存器组成如下:   
        1. 34 个通用寄存器,包括 R15 程序计数器(PC),这些寄存器都是 32 位的。
        2. 8 个状态寄存器,包括 CPSR 和 SPSR。
        3. Hyp 模式下独有一个 ELR_Hyp 寄存器。

通用寄存器
----------------
    R0~R15 就是通用寄存器,通用寄存器可以分为以下三类:

    - 未备份寄存器,即 R0~R7。
    - 备份寄存器,即 R8~R14。
    - 程序计数器 PC,即 R15。

    1. 未备份寄存器  
        未备份寄存器指的是 R0~R7 这 8 个寄存器,因为在所有的处理器模式下这 8 个寄存器都是
        同一个物理寄存器,在不同的模式下,这 8 个寄存器中的数据就会被破坏。所以这 8 个寄存器
        并没有被用作特殊用途。
    
    2. 备份寄存器
        备份寄存器中的 R8~R12 这 5 个寄存器有两种物理寄存器,在快速中断模式下(FIQ)它们对
        应着 Rx_irq(x=8~12)物理寄存器,其他模式下对应着 Rx(8~12)物理寄存器。因为 FIQ 
        模式下的 R8~R12 是独立的,因此中断处理程序可以不用执行保存和恢复中
        断现场的指令,从而加速中断的执行过程。

        R13是栈指针寄存器(SP),R14是连接寄存器(LR),R15是程序计数寄存器(PC)。

        :SP R13:
            R13一共有 8 个物理寄存器,其中一个是用户模式(User)和系统模式(Sys)共用
            的,剩下的 7 个分别对应 7 种不同的模式。其用来做为栈指针。基本上每种模式
            都有一个自己的 R13 物理寄存器,应用程序会初始化 R13,使其指向该模式专用的栈地址。

        :LR R14:
            R14 一共有 7 个物理寄存器,其中一个是用户模式(User)、系统模式(Sys)和超
            级监视模式(Hyp)所共有的,剩下的 6 个分别对应 6 种不同的模式。

            LR 寄存器在 ARM 中主要用作如下两种用途:

            -   每种处理器模式使用 R14(LR)来存放当前子程序的返回地址,如果使用 BL 或者 BLX
                来调用子函数的话,R14(LR)被设置成该子函数的返回地址,在子函数中,将 R14(LR)中的值赋
                给 R15(PC)即可完成子函数返回,比如在子程序中可以使用如下代码:
                ::
                    MOV PC, LR  @寄存器LR中的值赋值给PC,实现跳转
                        或者可以在子函数的入口出将LR入栈:
                    PUSH {LR}   @将 LR 寄存器压栈 
                        在子函数的最后面出栈即可:
                    POP {PC}    @将上面压栈的LR寄存器数据出栈给PC寄存器,严格意义上来讲应该是将
                                @LR-4 赋给 PC,因为 3 级流水线,这里只是演示代码。
            - 当异常发生以后,该异常模式对应的 R14 寄存器被设置成该异常模式将要返回的地址,R14 也可以当作普通寄存器使用。
        
        :PC R15:
            R15 保存着当前执行的指令地址值加 8 个字节,这是因为 ARM
            的流水线机制导致的。ARM 处理器 3 级流水线:取指->译码->执行,这三级流水线循环执行,
            比如当前正在执行第一条指令的同时也对第二条指令进行译码,第三条指令也同时被取出存放
            在 R15(PC)中。

            以当前正在执行的指令作为参考点,即第一条指令,则PC中存放的是第三条指令。
            简单而言,PC总是指向正在执行的指令地址机上2条指令地址。

            对32位ARM而言,每条指令4byte
            >>> PC= &正在执行的程序+2*4byte


程序状态寄存器
---------------
    所有的处理器模式都共用一个 CPSR 物理寄存器,因此 CPSR 可以在任何模式下被访问。               
    CPSR 是当前程序状态寄存器,该寄存器包含了条件标志位、中断禁止位、当前处理器模式标志
    等一些状态位以及一些控制位。

    所有的处理器模式都共用一个 CPSR 必然会导致冲突,为此,
    除了 User 和 Sys 这两个模式以外,其他 7 个模式每个都配备了一个专用的物理状态寄存器,叫
    做 SPSR(备份程序状态寄存器),当特定的异常中断发生时,SPSR 寄存器用来保存当前程序状
    态寄存器(CPSR)的值,当异常退出以后可以用 SPSR 中保存的值来恢复 CPSR。

    因为 User 和 Sys 这两个模式不是异常模式,所以并没有配备 SPSR,因此不能在 User 和
    Sys 模式下访问 SPSR,会导致不可预知的结果。由于 SPSR 是 CPSR 的备份,因此 SPSR 和
    CPSR 的寄存器结构相同,如图所示

    .. image::  ./Picture/CPSR_Resister.png

    :N(bit31):
        补码表示,有符号整数运算的时候, N=1 表示运算对的结果为负数, N=0表示结果为正数。

    :Z(bit30):
        Z=1 表示运算结果为零,Z=0 表示运算结果不为零,对于 CMP 指令,Z=1 表示
        进行比较的两个数大小相等。

    :C(bit29):
        在加法指令中,当结果产生了进位,则 C=1,表示无符号数运算发生上溢,其它
        情况下 C=0。在减法指令中,当运算中发生借位,则 C=0,表示无符号数运算发生下溢,其它
        情况下 C=1。对于包含移位操作的非加/减法运算指令,C 中包含最后一次溢出的位的数值,对
        于其它非加/减运算指令,C 位的值通常不受影响。

    :V(bit28):
        对于加/减法运算指令,当操作数和运算结果表示为二进制的补码表示的带符号
        数时,V=1 表示符号位溢出,通常其他位不影响 V 位。

    :Q(bit27):
        仅 ARM v5TE_J 架构支持,表示饱和状态,Q=1 表示累积饱和,Q=0 表示累积不饱和。
    
    :IT[7:0]:
        由IT[1:0](bit26:25):和 IT[7:2](bit15:bit10)一起组成 IT[7:0],作为 IF-THEN 指令执行状态。

    J(bit24):
        仅 ARM_v5TE-J 架构支持,J=1 表示处于 Jazelle 状态,此位通常和 T(bit5)位一起
        表示当前所使用的指令集,如表
        
        =========   =========   =================
        J               T           描述
        =========   =========   =================
        0               0           ARM
        0               1           Thumb
        1               1           ThumbEE
        1               0           Jazelle
        =========   =========   =================        

        ::
            Jazelle 技术是 ARM 提供的组合型硬件和软件解决方案。ARM Jazelle 技术软件
            是功能丰富的多任务 Java 虚拟机 (JVM),经过高度优化,可利用许多 ARM 处理器
            内核中提供的 Jazelle 技术架构扩展。
        
        :GE[3:0](bit19:16):
            SIMD 指令有效,大于或等于。

        :IT[7:2](bit15:10):
            参考 IT[1:0]。

        :E(bit9):
            大小端控制位,E=1 表示大端模式,E=0 表示小端模式。
        
        :A(bit8):
            禁止异步中断位,A=1 表示禁止异步中断。

        :I(bit7):
            I=1 禁止 IRQ,I=0 使能 IRQ。

        :F(bit6):
            F=1 禁止 FIQ,F=0 使能 FIQ。

        :T(bit5):
            控制指令执行状态,表明本指令是 ARM 指令还是 Thumb 指令,通常和 J(bit24)一起表明指令类型,参考 J(bit24)位。
            
        :M[4:0]:
            处理器模式控制位,含义如表

            =============   ================================
                M[4:0]              处理器模式
            =============   ================================
                10000           User 模式
                10001           FIQ 模式
                10010           IRQ 模式
                10011           Supervisor(SVC)模式
                10110           Monitor(MON)模式
                10111           Abort(ABT)模式
                11010           Hyp(HYP)模式
                11011           Undef(UND)模式
                11111           System(SYS)模式
            =============   ================================


Cortex-A7 MPCore
=========================


    Cortex-A7 MPCore 支持在一个处理器上选配 1~4 个内核, Cortex-A7 MPCore 多核配置如图

    .. image:: ./Picture/Cortex-A7_MPCoreMultiCore.png

    Cortex-A7 MPCore 的 L1 可选择 8KB、16KB、32KB、64KB,L2 Cache 可以不配,也可以
    选择 128KB、256KB、512KB、1024KB。

    Cortex-A7MPCore 使用 ARMv7-A 架构,主要特性如下:

    #. SIMDv2 扩展整形和浮点向量操作。
    #. 提供了与 ARM VFPv4 体系结构兼容的高性能的单双精度浮点指令,支持全功能的IEEE754。
    #. 支持大物理扩展(LPAE),最高可以访问 40 位存储地址,也就是最高可以支持 1TB 的内存。
    #. 支持硬件虚拟化。
    #. 支持 Generic Interrupt Controller(GIC)V2.0。
    #. 支持 NEON,可以加速多媒体和信号处理算法。


