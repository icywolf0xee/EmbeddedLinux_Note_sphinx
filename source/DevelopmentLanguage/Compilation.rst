=============
ARM常用汇编指令
=============

参考:
    博客园：   
        - https://www.cnblogs.com/hojor/p/3517163.html
        - https://www.cnblogs.com/jiek/p/15501184.html
    【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.5.2

ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition下载地址

https://developer.arm.com/documentation/ddi0406/cd   (2024_1_1)

https://documentation-service.arm.com/static/5f8daeb7f86e16515cdb8c4e?token=     (2024_1_1)
::
    wget https://documentation-service.arm.com/static/5f8daeb7f86e16515cdb8c4e?token=


ARM的寻址方式
================
    寻址方式就是处理器根据指令中给出的地址信息来寻找物理地址的方式，目前ARM指令系统支持以下几种寻址方式：立即数寻址、寄存器寻址、寄存器偏移寻址、寄存器间接寻址、基址变址寻址、多寄存器寻址、相对寻址、堆栈寻址和块拷贝寻址

------------
立即寻址
------------
    也称为立即数寻址，这种寻址方式指令中就已经给出了操作数。也就是在执行指令的过程中，处理器取得指令的同时也取得了操作数，因此称为立即数寻址。例如：
    ::
        ADD  R0, #1                 ;R0+1->R0
        ADD  R0, R0, #0x3F          ;R0+0x3F->R0
    其中源操作数就是立即数，要求以“#”开始，对于十六进制的立即数，要求在“#”后面加“0x”或“&”。

------------
寄存器寻址
------------
    即将寄存器中的数值作为操作数，是各类微处理器常用的寻址方式，也是效率较高的寻址方式。例如：
    ::
        ADD  R0, R1, R2            ;R1+R2->R0,将R1和R2的值相加，将结果存入R0

------------
寄存器间接寻址
------------
    寄存器间接寻址是以寄存器中的值作为操作数的地址，操作数本身存放在寄存器中。例如：
    ::
        ADD  R0, R1, [R2]           ;R1+[R2]->R0
        LDR   R0, [R1]              ;[R1]->R0
        ;第一条指令，以寄存器R2的值作为操作数的地址，在寄存器中取得一个操作数后与R1相加，将结果存入寄存器R0。
        ;第二条指令，将寄存器中以R1为地址的值赋给R0。

    [R0]表示以R0寄存器的值为地址的值作为实际值。(类似C语言*R0)
    
    R0表示寄存器的值作为实际值。

------------
基址变址寻址
------------
    基址变址寻址是把基址寄存器的内容与指令中给出的地址偏移量相加，从而得到一个操作数的有效地址。该方式常用于访问基地址附近的某些存储单元，一般有以下几种方式：

    将寄存器R1的值加上4作为操作数的有效地址，取得操作数后存入R0中，代码如下

    >>> LDR   R0, [R1, #4]        ;[R1+4]->R0

    将寄存器R1的值加上4作为操作数的有效地址，取得操作数后存入R0中，然后寄存器R1的值加上4个字节，代码如下

    >>> LDR   R0, [R1, #4]!       ;[R1+4]->R0、R1+4->R1

    将寄存器R1的值作为操作数的有效地址，取得操作数后存入R0中，然后寄存器R1的值加上4个字节，代码如下

    >>> LDR   R0, [R1]， #4      ;[R1]->R0、R1+4->R1

    将寄存器R1和R2的值相加作为操作数的有效地址，取得操作数后存入R0中，代码如下

    >>> LDR   R0, [R1, R2]       ;[R1+R2]->R0


------------
多寄存器寻址
------------
    用多寄存器寻址，一条指令可以完成多个寄存器值的传送，一条指令最多可以传送16个通用寄存器的值。例如：
    
    >>>LDMIA  R0, {R1,R2,R3,R4,}      ;[R0]->R1,[R0+4]->R2,[R0+8]->R3,[R0+12]->R4

    该指令后缀IA表示每次执行完读取/存储操作后，R0按字长增加，因此，指令可以将连续存储单元的值传送到R1~R4。


------------
相对寻址
------------
    与基址变址寻址类似，相对寻址以程序计数器PC的当前值作为基地址，指令中的地址标号作为偏移量，将两者相加后得到操作数的有效地址。以下程序完成子程序的调用和返回，跳转指令BL采用了相对寻址方式：
    ::
        BL    NEXT           ;跳转到子程序NEXT处执行指令
        ......
        NEXT
        ......
        MV  PC, LR         ;从子程序返回

------------
堆栈寻址
------------
堆栈是一种数据结构，按先进后出的方式工作，使用一个称为堆栈指针的专用寄存器指示当前的操作，堆栈指针总是指向堆栈顶端。

    - 当堆栈指针指向最后压入的数据时，称为满堆栈；
    - 当堆栈指针指向下一个将要压入的位置时，称为空堆栈。

根据堆栈的生成方式，可分为递增堆栈和递减堆栈。当堆栈由低地址向高地址生成时，称为递增堆栈，反之称为递减堆栈。排列组合后可得到4中类型的堆栈工作方式，ARM微处理器支持全部4种类型的堆栈工作方式，如下：

    - 满递增堆栈：堆栈指针指向最后压入的数据，由低地址向高地址生成。
    - 满递减堆栈：堆栈指针指向最后压入的数据，由高地址向低地址生成。
    - 空递增堆栈：堆栈指针指向下一个将要压入数据的空位置，由低地址向高地址生成。
    - 空递减堆栈：堆栈指针指向下一个将要压入数据的空位置，由高地址向低地址生成



Cortex-A常用汇编指令
===========

-------------------
处理器内部数据传输指令
-------------------
    处理器内部数据传输主要有以下三个操作：

    - 将数据从一个寄存器传递到另外一个寄存器
    - 将数据从一个寄存器传递到特殊寄存器，如 CPSR 和 SPSR 寄存器
    - 将立即数传递到寄存器

    常用指令有：

    ==========      ==========      ==========   ========================================
    指令             目标               源          功能
    ==========      ==========      ==========   ========================================
    MOV              R0                R1        将R1数据复制到R0(R0=R1)
    MRS              R0                CPSR      将特殊寄存器CPSR中的数据复制到R0(R0=CPSR)
    MSR              CPSR              R1        将R1中的数据复制到特殊寄存器CPSR(CPSR=R1)
    ==========      ==========      ==========   ========================================

    -  MOV指令
        MOV 指令用于将数据从一个寄存器拷贝到另外一个寄存器，或者将一个立即数传递到寄存器里面
        ::
            MOV R0，R1 		@将寄存器 R1 中的数据传递给 R0，即 R0=R1
            MOV R0, #0X12	 @将立即数 0X12 传递给 R0 寄存器，即 R0=0X12

   -  MRS指令
        MRS 指令用于将特殊寄存器(如 CPSR 和 SPSR)中的数据传递给通用寄存器，要读取特殊寄存器的数据只能使用 MRS 指令
        ::
            MRS R0, CPSR 	@将特殊寄存器 CPSR 里面的数据传递给 R0，即 R0=CPSR


   -  MSR指令
        MSR 指令用来将普通寄存器的数据传递给特殊寄存器，也就 是写特殊寄存器，写特殊寄存器只能使用 MSR
        ::
            MSR CPSR, R0	 @将 R0 中的数据复制到 CPSR 中，即 CPSR=R0

-------------------
存储器访问指令
-------------------
    ARM 不能直接访问存储器，比如 RAM 中的数据，配置寄存器的时候需要借助存储器访问指令，一般先将要配置的值 写入到 Rx(x=0~12)寄存器中，然后借助存储器访问指令将 Rx 中的数据写入到 I.MX6UL 寄存器中。读取 I.MX6UL 寄存器也是一样的，只是过程相反。常用的存储器访问指令有两种：LDR 和 STR，用法如表:

    =======================     ========================================================================
        指令                        描述
    =======================     ========================================================================
    LDR Rd, [Rn , #offset]          从存储器 Rn+offset 的位置读取数据存放到 Rd 中。
    STR Rd, [Rn, #offset]           将 Rd 中的数据写入到存储器中的 Rn+offset 位置。
    =======================     ========================================================================

    - LDR指令
        LDR 主要用于从存储器加载数据到寄存器 Rx 中，LDR 也可以将一个立即数加载到寄存器 Rx 中，LDR 加载立即数的时候要使用“=”，而不是“#”。在嵌入式开发中，LDR 最常用的就是读 取 CPU 的寄存器值，比如 I.MX6UL 有个寄存器 GPIO1_GDIR，其地址为 0X0209C004，要读取这个寄存器中的数据，代码如下:
        ::
            LDR R0, =0X0209C004     @将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004
            LDR R1, [R0] 		    @读取地址 0X0209C004 中的数据到 R1 寄存器中

    -   STR
        STR 就是将数据写入到存储器中，同样以 I.MX6UL 寄存器 GPIO1_GDIR 为例，现在我们要配置寄存器 GPIO1_GDIR 的值为 0X20000002，示例代码如下:
        ::
            LDR R0, =0X0209C004     @将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004
            LDR R1, =0X20000002     @R1 保存要写入到寄存器的值，即 R1=0X20000002
            STR R1, [R0] 			@将 R1 中的值写入到 R0 中所保存的地址对应的内存中
        
        LDR 和 STR 都是按照字进行读取和写入的，也就是操作的 32 位数据，如果要按照字节、 半字进行操作的话可以在指令“LDR”后面加上 B 或 H，比如按字节操作的指令就是 LDRB 和 STRB，按半字操作的指令就是 LDRH 和 STRH

-------------------
压栈和出栈指令
-------------------
    函数在运行时，临时存储数据的寄存器是R0-R15，函数运行结束或者切换的时候，需要保存当前运行的参数（保护现场），即把当前寄存器的数据通过SP指针压入到堆栈里面，进行保存，当函数继续运行时，则将原先保存在堆栈的数据弹出到当前R0-R15中（恢复现场）继续运行；。压栈 的指令为 PUSH，出栈的指令为 POP，PUSH 和 POP 是一种多存储和多加载指令（就是实际上执行多条指令），即可以一次 操作多个寄存器数据，他们利用当前的栈指针 SP 来生成地址，PUSH 和 POP 的用法如表：

    ============    ================================================
    指令                描述
    ============    ================================================  
    PUSH                将寄存器列表存入栈中
    POP                 从栈中恢复寄存器列表
    ============    ================================================

    假如我们现在要将 R0~R3 和 R12 这 5 个寄存器压栈，当前的 SP 指针指向 0X80000000，处理器的堆栈是向下增长的，使用的汇编代码如下：
    >>> PUSH {R0~R3, R12} @将 R0~R3 和 R12 压栈

    压栈后的堆栈SP指针如下：

    .. image:: ./Picture/PushSPStack.png

    如果我们要出栈的话 就是使用如下代码：

    >>> POP {R0~R3,R12} @恢复 R0~R3,R12

    出栈的就是从栈顶，也就是 SP 当前执行的位置开始，地址依次减小来提取堆栈中的数据 到要恢复的寄存器列表中，PUSH 和 POP 的另外一种写法是“STMFD SP！”和“LDMFD SP!”，功能和上面的相同。

    上述代码可改写成
    ::
        STMFD SP!,{R0~R3, R12}      @R0~R3,R12 入栈
        STMFD SP!,{LR}              @LR 入栈
       
        LDMFD SP!, {LR}             @先恢复 LR        
        LDMFD SP!, {R0~R3, R12}     @再恢复 R0~R3, R12
        
    STMFD分为两部分：STM、FD；LDMFD分为LDM、FD。和上述LDR和STR一样都是数据加载和存储指令，不同的是STM和LDM是多存储和家在，连续读写存储器中
    多个连续的值。

    FD为Full Descending，满递减。根据ATPCS，ARM的FD类型堆栈，SP指向最后入栈的值，堆栈地址由高地址向下增长，即地址减小。
    STM和LDM中指令寄存器列表编号小对应低地址，编号高对应高地址。


-------------------
跳转指令
-------------------

    跳转一般有两种操作：

    -    直接使用跳转指令 B、BL、BX 等
    -    直接向 PC 寄存器里面写入数据

    指令跳转：

    ===================     =========================================================================================================
    指令                        描述
    ===================     =========================================================================================================
    B<label>                    跳转到 label，如果跳转范围超过了+/-2KB，可以指定 B.W 使用 32 位版本的跳转 

                                指令，这样可以得到较大范围的 跳转 BX 间接跳转，跳转到存放于 Rm 中的地址处，
                                
                                并且切换指令集。

    BX<Rm>                      间接跳转，跳转到存放于 Rm 中的地址处，并且切换指令集
    BL<label>                   跳转到标号地址，并将返回地址保存在 LR 中。
    BLX<Rm>                     结合 BX 和 BL 的特点，跳转到 Rm 指定的地址，并将返回地 址保存在 LR 中，
    
                                切换指令集
    ===================     =========================================================================================================

    -   B指令
        B 指令会将 PC 寄存器的值设置为跳转目标地址， 一旦执行 B 指 令，ARM 处理器就会立即跳转到指定的目标地址，一般用于不会返回的跳转，
        如下为启动程序完成后最后跳转到main函数开始执行C语言程序！
        ::
            _start:

                ldr sp,=0X80200000      @设置栈指针
                b main                  @跳转到 main 函数
    
    -   BL指令
        BL 指令相比 B 指令，在跳转之前会在寄存器 LR(R14)中保存当前 PC 寄存器值，所以可以 通过将 LR 寄存器中的值重新加载到 
        PC 中来继续从跳转之前的代码处运行，一般用于需要返回的跳转，比如子程序调用，因为 B 指令一旦跳转就再也不会回来了，这个时
        候要使用 BL 指令或者进入中断的情况，如下就是进入中断跳转
        ::
            push {r0, r1}               @保存 r0,r1
            cps #0x13                   @进入 SVC 模式，允许其他中断再次进去
            bl system_irqhandler        @加载 C 语言中断处理函数到 r2 寄存器中
            cps #0x12                   @进入 IRQ 模式
            pop {r0, r1}                @r0,r1压入栈
            str r0, [r1, #0X10]         @中断执行完成，写 EOIR

-------------------
算术运算指令
-------------------

========================    ========================   ========================================================
指令                            计算公式                    备注
========================    ========================   ========================================================
ADD Rd, Rn, Rm              Rd = Rn + Rm                无进位加法，指令ADD
ADD Rd, Rn, #immed          Rd = Rn + #immed            无进位加法，指令ADD


ADC Rd, Rn, Rm              Rd = Rn + Rm + 进位          有进位加法，指令ADD
ADC Rd, Rn, #immed          Rd = Rn + #immed +进位       有进位加法，指令ADD


SUB Rd, Rn, Rm              Rd = Rn – Rm                无借位减法
SUB Rd, #immed              Rd = Rd - #immed            无借位减法，类似Rd-=#immed
SUB Rd, Rn, #immed          Rd = Rn - #immed            无借位减法


SBC Rd, Rn, #immed          Rd = Rn - #immed – 借位     有借位减法，变量与立即数
SBC Rd, Rn ,Rm              Rd = Rn – Rm – 借位         有借位减法，两变量

MUL Rd, Rn, Rm              Rd = Rn * Rm                乘法(上限32 位)

UDIV Rd, Rn, Rm             Rd = Rn / Rm                无符号除法

SDIV Rd, Rn, Rm             Rd = Rn / Rm                有符号除法
========================    ========================   ========================================================

-------------------
算术运算指令
-------------------


========================    ========================   ========================================================
指令                            计算公式                    备注
========================    ========================   ========================================================
AND Rd, Rn                  Rd = Rd &Rn                 按位与  
AND Rd, Rn, #immed          Rd = Rn &#immed             按位与
AND Rd, Rn, Rm              Rd = Rn & Rm                按位与

ORR Rd, Rn                  Rd = Rd | Rn                按位或
ORR Rd, Rn, #immed          Rd = Rn | #immed            按位或
ORR Rd, Rn, Rm              Rd = Rn | Rm                按位或


BIC Rd, Rn                  Rd = Rd & (~Rn)             位清除
BIC Rd, Rn, #immed          Rd = Rn & (~#immed)         位清除
BIC Rd, Rn , Rm             Rd = Rn & (~Rm)             位清除


ORN Rd, Rn, #immed          Rd = Rn | (#immed)          按位或非
ORN Rd, Rn, Rm              Rd = Rn | (Rm)              按位或非

EOR Rd, Rn                  Rd = Rd ^ Rn                按位异或
EOR Rd, Rn, #immed          Rd = Rn ^ #immed            按位异或
EOR Rd, Rn, Rm              Rd = Rn ^ Rm                按位异或
========================    ========================   ========================================================





