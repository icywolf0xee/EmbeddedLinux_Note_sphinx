=========
Linux GUN汇编语法
=========

参考:
    博客园：   
        - https://www.cnblogs.com/hojor/p/3517163.html
        - https://www.cnblogs.com/jiek/p/15501184.html
    【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.5.2


Linux需要使用汇编的原因
=====================
    作为最基本的编程语言之一，汇编语言虽然应用的范围不算很广，但重要性却勿庸置疑，因为它能够完成许多其它语言所无法完成的功能。就拿 Linux 内核来讲，虽然绝大部分代码是用 C 语言编写的，但仍然不可避免地在某些关键地方使用了汇编代码，其中主要是在 Linux 的启动部分。由于这部分代码与硬件的关系非常密切，即使是 C 语言也会有些力不从心，而汇编语言则能够很好扬长避短，最大限度地发挥硬件的性能。

    多数情况下 Linux 程序员不需要使用汇编语言，因为即便是硬件驱动这样的底层程序在 Linux 操作系统中也可以用完全用 C 语言来实现，再加上 GCC 这一优秀的编译器目前已经能够对最终生成的代码进行很好的优化，的确有足够的理由让我们可以暂时将汇编语言抛在一边了。但实现情况是 Linux 程序员有时还是需要使用汇编，或者不得不使用汇编，理由很简单：精简、高效和 libc 无关性。假设要移植 Linux 到某一特定的嵌入式硬件环境下，首先必然面临如何减少系统大小、提高执行效率等问题，此时或许只有汇编语言能帮上忙了。

    汇编语言直接同计算机的底层软件甚至硬件进行交互，它具有如下一些优点：

    -    能够直接访问与硬件相关的存储器或 I/O 端口。
    -    能够不受编译器的限制，对生成的二进制代码进行完全的控制。
    -    能够对关键代码进行更准确的控制，避免因线程共同访问或者硬件设备共享引起的死锁。
    -    能够根据特定的应用对代码做最佳的优化,提高运行速度。
    -    能够最大限度地发挥硬件的功能。

    同时还应该认识到，汇编语言是一种层次非常低的语言，它仅仅高于直接手工编写二进制的机器指令码，因此不可避免地存在一些缺点：

    -    编写的代码非常难懂，不好维护。
    -    很容易产生 bug,难于调试。
    -    只能针对特定的体系结构和处理器进行优化。
    -    开发效率很低，时间长且单调。

    Linux 下用汇编语言编写的代码具有两种不同的形式。第一种是完全的汇编代码，指的是整个程序全部用汇编语言编写。尽管是完全的汇编代码，Linux 平台下的汇编工具也吸收了 C 语言的长处，使得程序员可以使用 #include、#ifdef 等预处理指令，并能够通过宏定义来简化代码。第二种是内嵌的汇编代码，指的是可以嵌入到C语言程序中的汇编代码片段。虽然 ANSI 的 C 语言标准中没有关于内嵌汇编代码的相应规定，但各种实际使用的 C 编译器都做了这方面的扩充，这其中当然就包括 Linux 平台下的 GCC。


GUN汇编语法
================

----------------
    语句格式
----------------
    GNU汇编语法适用于所有的架构，并不是 ARM 独享的，GNU 汇编由一系列的语句组成， 每行一条语句，每条语句有三个可选部分，如下：

    >>> label：instruction  		@ comment

    ===================             ==========================================================================
     组成                                 功能
    ===================             ==========================================================================
     label                              标号，表示指令地址位置，有些指令前面可能会有标号，这样就可以通过这

                                        个标号得到指令的地址，标号也可以用来表示数据地址。注意 label 后面

                                        的“：”，任何以“：”结尾的标识 符都会被识别为一个标号。

    instruction                         指令，也就是汇编指令或伪指令。

    @comment                            注释内容（@符号，表示后面的是注释）
    ===================             ==========================================================================
    例如如下代码：

    >>> add:
            MOVS R0,#0X12 @将R0=0X12

    add是标号，表示指令地址，后面可以通过标号进行跳转(感觉在某种角度上类似C语言中goto中的label?)，MOV R0 ,#0x12将立即数赋值给R0寄存器。



-------------
伪操作
-------------
    
    -   所有指令、伪操作、寄存器等大小写都可以，但是必须要保证同一，不可大小写混用
    -   伪操作，其操作对象是汇编编译器；而伪指令，其最终的操作对象是指令，也就是说，其对应的是用于CPU执行的指令。这就是他们之间简单但很微妙的区别。
    -   伪指令最终面对的是CPU指令集的指令。伪操作是用来控制汇编器是如何来产生汇编指令的。

    用户可以使用.section（伪操作）来定义一个段，每个段以段名开始，以下一段名或者文件结尾结束。
    例如：
        >>> .section .testsection @定义一个testsection段
    
    汇编程序的默认入口标号是_start,也可以在连接脚本中使用ENTRY指定其他程序入口。
    ::
        .global _start

        _start:
            ldr r0,0x12 @r0=0x12
    
    .global个全局标号,声明之后，.global _start 让_start符号成为可见的标示符，这样链接器就知道跳转到程序中的什么地方并开始执行，linux寻找这个 _start标签作为程序的默认进入点
    
    汇编系统预定义了一些段名如下(部分)： 
    
    ===========       ==========================================================================================
    伪操作                功能
    ===========       ==========================================================================================
    .text               表示代码段
    .data               初始化数据段
    .bss                未初始数据段
    .rodata             只读数据段
    .byte               定义单字节数据,例如.byte 0x12
    .short              定义双字节数据,例如.short 0x1234
    .long               定义四字节数据,例如.long 0x12345678
    .equ                赋值语句，格式为:.equ <变量名>,<表达式>,例如.equ num,0x12,即num=0x12
    .align              数据字节对齐,例如.align 4,表示4字节对齐
    .end                表示源文件结束
    .global             定义全局符号，类似C语言中全局变量，格式为.global symbol,例如:.global _start
    extern XXXX         说明XXXX为外部函数,调用是可以便利所有文件找到该函数并使用他
    ===========       ==========================================================================================
    - 详情参考《arm-cortex-a-prog-guide-v4》,下载链接在“Linux GCC基础”中。

-------------
GUN汇编函数
-------------
    GUN语法支持函数，函数格式如下：
    ::
        函数名:
            函数体
            返回语句

    Cortex-A7的中断服务函数
    ::
        /* 未定义中断 */
        Undefined_Handler:
            ldr r0, =Undefined_Handler
            bx r0
        /* SVC 中断 */
        SVC_Handler:
            ldr r0, =SVC_Handler
            bx r0
        /* 预取终止中断 */
        PrefAbort_Handler:
            ldr r0, =Pref
            bx r0
    - “SVC_Handler” 就是函数名。
    - “ldr r0, =SVC_Handler”是函数体。
    - “bx r0”是函数返回语句，“bx”指令是返回指令，函数返回语句不是必须的。




Linux汇编语法格式
================
    DOS/Windows 下的汇编语言，这些汇编代码都是 Intel 风格的。但在 Unix 和 Linux 系统中，更多采用的还是 AT&T 格式，两者在语法格式上有着很大的不同。

    -   在 AT&T 汇编格式中，寄存器名要加上 '%' 作为前缀；而在 Intel 汇编格式中，寄存器名不需要加前缀。

        ==========            ==========
            AT&T                 Intel
        ==========            ==========
        pushl %eax              push eax
        ==========            ==========
    -   在 AT&T 汇编格式中，用 '$' 前缀表示一个立即操作数；而在 Intel 汇编格式中，立即数的表示不用带任何前缀。

        ==========            ==========
            AT&T                 Intel
        ==========            ==========
          pushl $1             push 1
        ==========            ==========    
    -   AT&T 和 Intel 格式中的源操作数和目标操作数的位置正好相反。在 Intel 汇编格式中，目标操作数在源操作数的左边；而在 AT&T 汇编格式中，目标操作数在源操作数的右边。

        ====================            ====================
            AT&T                            Intel
        ====================            ====================
        addl $1, %eax                      add eax, 1
        ====================            ==================== 
    -   在 AT&T 汇编格式中，操作数的字长由操作符的最后一个字母决定，后缀'b'、'w'、'l'分别表示操作数为字节（byte，8 比特）、字（word，16 比特）和长字（long，32比特）；而在 Intel 汇编格式中，操作数的字长是用 "byte ptr" 和 "word ptr" 等前缀来表示的。

        ====================            ====================
            AT&T                            Intel
        ====================            ====================
        movb val, %al                    mov al, byte ptr val
        ====================            ====================    
    -   在 AT&T 汇编格式中，绝对转移和调用指令（jump/call）的操作数前要加上'*'作为前缀，而在 Intel 格式中则不需要。
    -   远程转移指令和远程子调用指令的操作码，在 AT&T 汇编格式中为 "ljump" 和 "lcall"，而在 Intel 汇编格式中则为 "jmp far" 和 "call far"，即：

        ==========================            ==========================
            AT&T                                 Intel
        ==========================            ==========================
        ljump $section, $offset	                jmp far section:offset
        lcall $section, $offset                 call far section:offset
        ==========================            ========================== 
        与之相应的远程返回指令则为：

        ======================            ======================
            AT&T                                Intel
        ======================            ======================
            lret $stack_adjust              ret far stack_adjust
        ======================            ======================
    -   在 AT&T 汇编格式中，内存操作数的寻址方式是:

        >>> section:disp(base, index, scale)

        而在 Intel 汇编格式中，内存操作数的寻址方式为：

        >>> section:[base + index*scale + disp]

        由于 Linux 工作在保护模式下，用的是 32 位线性地址，所以在计算地址时不用考虑段基址和偏移量，而是采用如下的地址计算方法：
        disp + base + index * scale

        下面是一些内存操作数的例子：

        =================================            =================================
            AT&T                                            Intel
        =================================            =================================
        movl -4(%ebp), %eax	                            mov eax, [ebp - 4]
        movl array(, %eax, 4), %eax                     mov eax, [eax*4 + array]
        movw array(%ebx, %eax, 4), %                    cxmov cx, [ebx + 4*eax + array]
        movb $4, %fs:(%eax)	                            mov fs:eax, 4
        =================================            ================================= 



GCC 内联汇编
============
    如果只是想对关键代码段进行优化，或许更好的办法是将汇编指令嵌入到 C 语言程序中，从而充分利用高级语言和汇编语言各自的特点。
    在 C 代码中嵌入汇编语句要比"纯粹"的汇编语言代码复杂得多，因为需要解决如何分配寄存器，以及如何与C代码中的变量相结合等问题。

    GCC 提供了很好的内联汇编支持，最基本的格式是：
    
    >>> __asm__("asm statements");

    例如：

    >>> __asm__("nop");

    如果需要同时执行多条汇编语句，则应该用"\\n\\t"或者"\\n\\r"将各个语句分隔开，例如：

    >>> _asm__( "pushl %%eax \\n\\t"
         "movl $0, %%eax \\n\\t"
         "popl %eax");

    通常嵌入到 C 代码中的汇编语句很难做到与其它部分没有任何关系，因此更多时候需要用到完整的内联汇编格式：

    >>> __asm__("asm statements" : outputs : inputs : registers-modified);

    下面是一个内联汇编的简单例子：

    .. code-block:: c

        int main()
        {
            int a = 10, b = 0;
            __asm__ __volatile__("movl %1, %%eax;\\n\\r"
                                "movl %%eax, %0;"
                                :"=r"(b)      /* 输出 */    
                                :"r"(a)       /* 输入 */
                                :"%eax");     /* 不受影响的寄存器 */
            
            printf("Result: %d, %d\\n", a, b);
        }

    上面的程序完成将变量a的值赋予变量b，有几点需要说明：

    -    变量b是输出操作数，通过%0来引用，而变量a是输入操作数，通过%1来引用。
    -    输入操作数和输出操作数都使用r进行约束，表示将变量a和变量b存储在寄存器中。输入约束和输出约束的不同点在于输出约束多一个约束修饰符'='。
    -    在内联汇编语句中使用寄存器eax时，寄存器名前应该加两个'%'，即%%eax。内联汇编中使用%0、%1等来标识变量，任何只带一个'%'的标识符都看成是操作数，而不是寄存器。
    -    内联汇编语句的最后一个部分告诉GCC它将改变寄存器eax中的值，GCC在处理时不应使用该寄存器来存储任何其它的值。
    -    由于变量b被指定成输出操作数，当内联汇编语句执行完毕后，它所保存的值将被更新。

    在内联汇编中用到的操作数从输出部的第一个约束开始编号，序号从0开始，每个约束记数一次，指令部要引用这些操作数时，只需在序号前加上'%'作为前缀就可以了。需要注意的是，内联汇编语句的指令部在引用一个操作数时总是将其作为32位的长字使用，但实际情况可能需要的是字或字节，因此应该在约束中指明正确的限定符：

    ==================================  ==================================
    限定符                                                  意义
    ==================================  ==================================
        "m"、"v"、"o"	                    内存单元
        "r"	                               任何寄存器
        "q"	                               寄存器eax、ebx、ecx、edx之一
        "i"、"h"	                        直接操作数
        "E"和"F"	                        浮点数
        "g"	                                任意
        "a"、"b"、"c"、"d"	                分别表示寄存器eax、ebx、ecx和edx
        "S"和"D"	                        寄存器esi、edi
        "I"	                                常数（0至31）
    ==================================  ==================================